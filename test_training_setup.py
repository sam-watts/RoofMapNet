"""
Test script to verify the training setup works correctly.
"""

import torch
from roofmapnet.models.roofmapnet import RoofMapNet
from roofmapnet.config import M

# Set config values
M.image = type('obj', (object,), {'mean': [109.730, 103.832, 98.681], 'stddev': [22.275, 22.124, 23.229]})()
M.n_stc_posl = 300
M.n_stc_negl = 40
M.n_dyn_junc = 300
M.n_pts0 = 64
M.n_pts1 = 8
M.dim_loi = 128
M.dim_fc = 1024
M.use_cood = 1
M.use_slop = 1
M.use_conv = 0
M.n_out_line = 2500
M.eval_junc_thres = 0.008
M.head_size = [[2], [1], [2]]

print("=" * 60)
print("Testing RoofMapNet Training Setup")
print("=" * 60)

# Create model
print("\n1. Creating model...")
model = RoofMapNet(depth=4, head=2, num_stacks=2, num_blocks=1, num_classes=5)
model.train()
print("✓ Model created successfully")

# Create dummy batch
batch_size = 2
print(f"\n2. Creating dummy batch (batch_size={batch_size})...")

dummy_image = torch.randn(batch_size, 3, 512, 512)
dummy_target = {
    "jmap": torch.rand(batch_size, 1, 128, 128),
    "joff": torch.rand(batch_size, 1, 2, 128, 128),
    "lmap": torch.rand(batch_size, 128, 128),
}

dummy_meta = []
for _ in range(batch_size):
    dummy_meta.append({
        "junc": torch.randn(10, 2) * 128,
        "jtyp": torch.zeros(10, dtype=torch.uint8),
        "Lpos": torch.zeros(11, 11, dtype=torch.uint8),
        "Lneg": torch.zeros(11, 11, dtype=torch.uint8),
        "lpre": torch.randn(340, 2, 2) * 128,
        "lpre_label": torch.cat([torch.ones(300), torch.zeros(40)]),
        "lpre_feat": torch.randn(340, 8),
    })

print("✓ Dummy batch created")

# Test training forward pass
print("\n3. Testing training forward pass...")
input_dict = {
    "image": dummy_image,
    "meta": dummy_meta,
    "target": dummy_target,
    "mode": "training"
}

try:
    with torch.no_grad():
        result = model(input_dict)
    print("✓ Forward pass successful")
except Exception as e:
    print(f"✗ Forward pass failed: {e}")
    import traceback
    traceback.print_exc()
    exit(1)

# Check outputs
print("\n4. Checking model outputs...")
print(f"   Output keys: {list(result.keys())}")

if "preds" in result:
    print(f"   Predictions keys: {list(result['preds'].keys())}")
    for key, val in result['preds'].items():
        if torch.is_tensor(val):
            print(f"     - {key}: shape {val.shape}, dtype {val.dtype}")
else:
    print("   ✗ No 'preds' in result!")
    exit(1)

if "targets" in result:
    print(f"   Targets keys (from model): {list(result['targets'].keys())}")
    for key, val in result['targets'].items():
        if torch.is_tensor(val):
            print(f"     - {key}: shape {val.shape}")
else:
    print("   ⚠ No 'targets' in result (will use batch targets)")

# Verify required outputs for loss computation
print("\n5. Verifying required outputs for loss computation...")
required_pred_keys = ['jmap', 'joff', 'lmap']
missing_keys = [k for k in required_pred_keys if k not in result['preds']]

if missing_keys:
    print(f"   ✗ Missing required prediction keys: {missing_keys}")
    exit(1)
else:
    print("   ✓ All required prediction keys present")

# Check training-specific outputs
training_keys = ['line_logits', 'line_labels']
has_training_outputs = all(k in result['preds'] for k in training_keys)
if has_training_outputs:
    print("   ✓ Training-specific outputs (line_logits, line_labels) present")
else:
    print(f"   ⚠ Training outputs missing: {[k for k in training_keys if k not in result['preds']]}")

# Check if gaussjmap is generated
if 'targets' in result and 'gaussjmap' in result['targets']:
    print("   ✓ Gaussian heatmap (gaussjmap) generated by model")
else:
    print("   ⚠ No gaussjmap in model outputs (will fallback to jmap for L_gauss)")

# Test inference mode
print("\n6. Testing inference forward pass...")
input_dict["mode"] = "inference"
try:
    with torch.no_grad():
        result_inf = model(input_dict)
    print("✓ Inference forward pass successful")
    
    if 'lines' in result_inf['preds'] and 'score' in result_inf['preds']:
        lines = result_inf['preds']['lines']
        scores = result_inf['preds']['score']
        print(f"   - lines shape: {lines.shape}")
        print(f"   - scores shape: {scores.shape}")
        print("   ✓ Inference outputs (lines, scores) present")
    else:
        print("   ✗ Missing inference outputs (lines, scores)")
        
except Exception as e:
    print(f"✗ Inference forward pass failed: {e}")
    import traceback
    traceback.print_exc()

# Test gradient flow
print("\n7. Testing gradient flow...")
try:
    model.zero_grad()
    input_dict["mode"] = "training"
    
    result = model(input_dict)
    
    # Compute a simple loss
    loss = result['preds']['jmap'].mean() + result['preds']['lmap'].mean()
    loss.backward()
    
    has_grads = any(p.grad is not None and p.grad.abs().sum() > 0 for p in model.parameters())
    if has_grads:
        print("✓ Gradients computed successfully")
    else:
        print("⚠ No gradients found (this might be okay if all outputs are detached)")
        
except Exception as e:
    print(f"✗ Gradient flow test failed: {e}")
    import traceback
    traceback.print_exc()

print("\n" + "=" * 60)
print("Training Setup Test Summary")
print("=" * 60)
print("✓ Model architecture: OK")
print("✓ Training forward pass: OK")
print("✓ Inference forward pass: OK")
print("✓ Required outputs: OK")

if has_training_outputs:
    print("✓ Training-specific outputs: OK")
else:
    print("⚠ Training-specific outputs: MISSING (will need to add line_logits)")

print("\n" + "=" * 60)
print("RECOMMENDATION:")
print("=" * 60)

if has_training_outputs:
    print("✓ Model is READY for training!")
    print("\nYou can now:")
    print("  1. Install pytorch-lightning: pip install pytorch-lightning")
    print("  2. Prepare your data using preprocess_rid2.py")
    print("  3. Run training: python -m roofmapnet.train.main --data-root /path/to/data")
else:
    print("⚠ Model needs updates for full training support:")
    print("\n  The model is missing training-specific outputs.")
    print("  The detection.py already has the code, just verify it's returning")
    print("  line_logits and line_labels during training mode.")
    print("\n  After fixing, the model will be ready for training!")

print("=" * 60)
